`2024-3-4`
+ `Object:kv_save` 与 `Object:kv_load` 支持值为表
+ UI事件枚举项修改：
  * `左键-按住`：废弃
  * `右键-按住`: 废弃
  * `左键-点击`: 新增
  * `右键-点击`: 新增

`2024-2-28`
+ 添加接口:
  * `Unit:set_move_channel_land` 设置单位的移动类型为地面
  * `Unit:set_move_channel_air` 设置单位的移动类型为空中
  * `Unit:set_move_collision` 设置单位是否计算某种碰撞类型
  * `Particle:set_color` 设置特效颜色
  * `Particle:set_visible` 设置特效显示

`2024-2-26`
+ 添加设置：
  * `y3.config.log.toFile` 是否将日志打印到日志文件中，默认为 `true`
  * `y3.config.log.toConsole` 是否将日志打印到控制台中，默认为 `true`

`2024-2-22`
+ 添加接口：
  * `y3.game.on_client_tick(callback)` 客户端每帧回调事件

`2024-2-19`
+ 添加了数据同步相关接口：
  * `y3.sync.send` 向所有玩家同步数据
  * `y3.sync.onSync` 注册数据同步后的回调

`2024-2-6`
+ 界面的鼠标事件支持右键相关事件

`2024-1-25`
+ 添加接口：
  * `PlayerGroup:clear()` 清空玩家组
  * `UnitGroup:clear()` 清空单位组

`2024-1-24`
+ 修复创建特效时没有传入时间时粒子可能看不见的bug

`2024-1-22`
+ 添加接口：
  * `Player:get_color` 获取玩家颜色字符串

`2024-1-19`
+ 添加接口：
  * `y3.game.get_obj_icon` 获取单位、物品、技能、魔法效果的图标

`2024-1-15`
+ 运动器添加字段：
  * `hit_interval` 碰撞同一个单位的间隔
  * `block_interval` 碰撞地形的间隔
+ 修复 `Buff:get_owner` 如果buff已被移除会报错的bug。现在此方法可能会返回 `nil` 。
+ 修复热重载没有维持文件加载顺序的bug

`2024-1-12`
+ 修复 `y3.game.send_custom_event` 无效的bug

`2023-12-25`
+ 添加接口：
  * `y3.game.get_current_server_time()` 返回当前的服务器时间

`2023-12-21`
+ 修复允许覆盖的存档表格修改后没有自动保存的bug

`2023-12-15`
+ 修复 `ProjectileGroup:pick` 报错的问题

`2023-12-14`
+ 以下接口可以使用编辑器中的名字作为参数了：
  * `y3.scene_ui.create_scene_ui_at_point`
  * `y3.scene_ui.create_scene_ui_at_player_unit_socket`

`2023-12-13`
+ 添加接口：
  * `UI:set_equip_slot_use_operation` 设置物品操作方式
  * `UI:set_equip_slot_drag_operation` 设置物品拖拽方式

`2023-11-29`
+ 修复 `游戏-消息` 事件没有传入事件ID的bug。

`2023-11-28`
+ 废弃了 `游戏-开始` 事件，请改用 `游戏-初始化` 事件。
+ 添加了 [Lua虚拟机](./doc/Lua虚拟机.md) 文档。

`2023-11-24`
+ 支持读写物编对象的自定义属性（包括在物编中预先配置的）：
  ```lua
  --134274912为“关羽”的ID
  y3.object.unit[134274912]:kv_has('自定义属性')
  y3.object.unit[134274912]:kv_load('自定义属性', 'number') -- 以 number 类型读取
  y3.object.unit[134274912]:kv_save('另一个属性', '某个字符串')
  ```

`2023-11-23`
+ 现在日志会写入到 `script/log/lua_player01.log` 中。在平台上运行时则会写入到 `<MAP>/custom/lua_player01.log` 中。多开时客户端会根据自己的本地玩家序号生成不同的日志。

`2023-11-21`
+ 修复曲线运动无法生效的bug

`2023-11-10`
+ 添加接口：
  * `UI:set_anim_pos`
+ 修复 `y3.object.item[key].on_add` 失效的bug

`2023-11-9`
+ 修复 `初始化配置.bat` 没有正确递归复制文件的bug

`2023-11-8`
+ `ECAFunction` 支持自动转换实数数组
+ 支持修改物编数据：
  ```lua
  local M = y3.object.unit[134274912] -- 关羽

  M.data.name = '这是修改过的名字'
  ```

  详情请参阅 `演示/物编`

`2023-11-7`
+ 添加接口：
  * `Unit:is_hero` 判断单位的类别是否是英雄
  * `Ability:pre_cast` 令技能进入瞄准状态
+ `Unit:damage` 参数字段添加 `text_track`
+ 修复 `UI:to_string` 返回值类型不是字符串的bug

`2023-11-6`
+ 将所有的接口导出为 markdown 文档，存放在 `doc/doc.md`
+ 修正了 `演示/ECA调用Lua函数` 中的一处错误（ECA代码中的 `args` 错写成了 `arg`）


`2023-11-3`
+ 以下类型可以由Lua管理生命周期了，因此可以使用对象事件并存储数据：
  * `Ability` - 技能
  * `Area` - 区域
  * `Cast` - 施法

`2023-10-27`
+ `UI:add_event` 支持传入自定义数据，可以在 `界面-消息` 事件中获取
+ 添加接口：
  * `y3.dump.encode`
  * `y3.dump.decode`

`2023-10-24`
+ 添加接口：
  * `y3.save_data.save_table`

`2023-10-20`
+ 添加存档模块
  * `y3.save_data.load_boolean`
  * `y3.save_data.save_boolean`
  * `y3.save_data.load_integer`
  * `y3.save_data.save_integer`
  * `y3.save_data.load_real`
  * `y3.save_data.save_real`
  * `y3.save_data.load_string`
  * `y3.save_data.save_string`
  * `y3.save_data.load_table`
+ 修正 `Item:is_in_scene` 在物品已移除的情况下会报错的bug
+ 修正 `Unit:move_to_pos` 不传第二个参数会报错的bug

`2023-10-19`
+ 添加本地计时器模块
  * `y3.ltimer.wait`
  * `y3.ltimer.loop`
  * `y3.ltimer.loop_count`
  * `y3.ltimer.wait_frame`
  * `y3.ltimer.loop_frame`
  * `y3.ltimer.loop_count_frame`

`2023-10-12`
+ 区域支持持久化
+ 修复创建区域会报错的bug
+ 修复选取单位不可用的bug

`2023-10-11`
+ 修复事件泄露

`2023-10-10`
+ 区域移除时会自动移除绑定的触发器
+ 调试器适配 `Lua Debug 2.X` 版本
+ 添加以下接口：
  * `y3.buff.get_by_id`
  * `y3.game:set_object_fresnel_visible`
  * `y3.game:set_object_fresnel`

`2023-10-9`
+ 添加以下接口:
  * `Player:kv_save`
  * `Player:kv_has`
  * `Player:kv_load`

`2023-10-7`
+ 添加以下接口：
  * `UI:set_anim_opacity`
  * `Unit:attr_to_name`
  * `Unit:attr_pick`

`2023-9-27`
+ 修复文件加载错误后此文件不会被热重载的bug
+ 修复以下接口返回值不是数字的bug：
  * `Timer:get_elapsed_time`
  * `Timer:get_remaining_time`
  * `Timer:get_time_out_time`
+ 添加以下接口：
  * `Ability:get_level() -> integer`

`2023-9-26`
+ 支持在玩家身上注册界面、按键与鼠标事件

`2023-9-25`
+ 支持在单位身上注册技能事件与效果事件

`2023-9-16`
+ 重命名以下接口：
  * `Ability:is_destory` -> `Ability:is_exist`: 之前的名称和实际不符

`2023-9-15`
+ 添加了接口：
  * `UI:is_removed`
+ 移除了以下事件：
  * `界面-创建`：此事件之前就是无效的
  * `界面-移除`：此事件之前就是无效的

`2023-9-13`
+ 添加了设置：
  * `y3.config.log.logger`：可以设置一个自定义的日志处理函数，在函数中返回 `true` 可以阻止原来的日志流程

`2023-9-11`
+ 支持从实体中读写自定义键值（与ECA互通）
  * 添加了一系列的接口，格式形如：
    - 保存自定义键值：`unit:kv_save('ABC', buff)`
    - 判断自定义键值存在：`unit:kv_has('ABC')`
    - 读取自定义键值：`unit:kv_load('ABC', 'Buff')`
  * 支持读写的容器对象（保存到谁身上）目前包含：
    - `Ability`
    - `Buff`
    - `Destructible`
    - `Item`
    - `Projectile`
    - `Unit`
    - `Area`
  * 支持读写的值（保存了什么）目前包含：
    - `boolean`
    - `integer`
    - `number`
    - `string`
    - `Unit`
    - `Ability`
    - `Item`
    - `Buff`
    - `Point`
    - `Player`
    - `Projectile`
    - `Destructible`
    - `Particle`
    - `Mover`

`2023-9-8`
+ 重命名以下接口：
  * `y3.ui_prefab.create_ui_prefab_instance` -> `y3.ui_prefab.create`
  * `UIPrefab:remove_ui_prefab` -> `UIPrefab:remove`

`2023-9-5`
+ 添加了以下接口：
  * `y3.timer.wait_frame`
  * `y3.timer.loop_frame`
  * `y3.timer.count_loop_frame`
+ 移除了以下事件：
  * `时间-经过`，改用 `y3.timer.wait`
  * `时间-周期`，改用 `y3.timer.loop`
  * `时间-经过帧`，改用 `y3.timer.wait_frame`
  * `时间-周期帧`，改用 `y3.timer.loop_frame`

`2023-9-4`
+ 重命名以下接口：
  * `y3.game.get_num_of_item_mat` -> `y3.item.get_num_of_item_mat`
  * `y3.game.get_num_of_player_attr` -> `y3.item.get_num_of_player_attr`
+ 移除了以下接口：
  * `y3.game.api_has_kv_any`
  * `y3.game.get_server_year`，改用 `os.date`
  * `y3.game.get_server_month`，改用 `os.date`
  * `y3.game.get_server_day`，改用 `os.date`
  * `y3.game.get_server_hour`，改用 `os.date`
  * `y3.game.string_gsub`，改用 `string.gsub`
+ 修复：
  * 以对象形式注册的 `单位-死亡` 事件无法正常触发

`2023-9-1`
+ 加回了 `y3.game.send_custom_event`
+ 重命名以下接口：
  * `y3.game.set_cure_value` -> `HealInstance:set_heal`
+ 移除了以下接口：
  * `y3.game.request_server_time`
  * `y3.game.get_client_player`，改用 `y3.player.get_local`

`2023-8-31`
+ 添加了事件：
  * `鼠标-悬停` ：悬停进入或离开都会触发
+ 移除了以下接口：
  * `y3.game.number_to_str`，改用 `tostring`
  * `y3.game.list_loop`，改用 `y3.helper.wrap_list`
  * `y3.game.set_lua_var`
  * `y3.game.get_lua_var`
  * `y3.game.init_lua_var`
  * `y3.game.send_custom_event`
  * `y3.game.is_in_radius`，改用 `Unit:is_in_radius`
  * `y3.game.any_var_to_str`
+ 重命名以下接口：
  * `y3.helper.wrap_list` -> `y3.helper.unpack_list`
  * `y3.helper.unwrap_list` -> `y3.helper.pack_list`
  * `y3.game.iter_role_res` -> `y3.player.get_res_keys`
  * `y3.game.exit_game` -> `Player:exit_game`
  * `y3.game.is_exist_key` -> `y3.game.table_has_key`

`2023-8-29`
+ 修改了热重载的实现方式，使其可以兼容“独立进程运行游戏”。不过热重载在此模式下无效，请改用“编辑器内运行游戏”来使用热重载。
+ 修复：
  * `Unit:add_ability` 报错
  * `y3.beam.create` 报错（#110）

`2023-8-28`
+ 重命名了以下接口
  * `Ability:get_ability_id` -> `Ability:get_key` 和其它类似方法保持一致
+ 可以对某个类型的对象批量指定事件
  ```lua
  local m = y3.object.ability[134221924]

  function m.on_cast_start(ability, cast)
      log.debug(('施法开始，技能为：%s，目标为：%s'):format(ability:get_name(), cast:get_target_unit()))
  end

  function m.on_cast_stop()
      log.debug('施法结束')
  end
  ```
+ 会自动判断当前是否为测试模式，你也可以使用 `y3.game.is_debug_mode()` 来判断。
+ 在测试模式下，启用了内置的测试指令（大小写均可）：
  * `.RD` - 重载脚本
  * `.SS` - 打印Lua中所有存活对象，结果保存在 `y3/log/snapshot.txt` 中
  * `.CT` - 打印Lua中所有存活对象以及它们的引用路径，结果保存在 `y3/log/catch.txt` 中

`2023-8-24`
+ 对象事件尽量使用消息模式
+ 地图配置添加：
  * `y3.const.log.level = 'debug'` - 设置日志等级，只会显示等级高于此的日志。
  * `y3.const.log.toDiaglog = true` - 是否将日志打印到 Diaglog 窗口中
  * `y3.const.log.toGame = false` - 是否将日志显示在游戏窗口中

`2023-8-23`
+ Class库重大改动，为了与普通方法进行区分以及拼写简单，重命名了这些拥有特殊功能的方法名：
  * `constructor` -> `__init`
  * `destructor` --> `__del`
  * `alloc` --> `__alloc`

`2023-8-18`
+ 支持引擎的对象事件，例如
  * `Unit:event('单位-死亡', callback)`
  * `Area:event('区域-进入', callback)`

`2023-8-17`
+ 支持了部分热重载，见 `演示/热重载/演示.lua`。
  * 提示：如果你想要完全由配置决定哪些文件可被重载，你可以加一行 `require = include`

`2023-8-15`
+ 支持了热重载，见 `演示/热重载/演示.lua`
+ 添加了以下接口：
  * `include` 用于热重载
  * `y3.develop.command.register(callback)`
+ 添加了以下配置：
  * `y3.config.debug = true` - 启用开发模式，允许使用测试指令等功能。目前需要你手动设置为 `true` 才能启用，未来默认会自动判断当前运行环境决定是否开启。

`2023-8-14`
+ 添加了以下接口：
  * `Unit:exchange_item(item, type, index)`

`2023-8-9`
+ 添加了自定义事件相关的接口：
  * `y3.game:event_on`
  * `y3.game:event_notify`
  * `y3.game:event_notify_with_args`
  * `y3.game:event_dispatch`
  * `y3.game:event_dispatch_with_args`
  * `Ability:event_on`
  * `Ability:event_notify`
  * `Ability:event_notify_with_args`
  * `Ability:event_dispatch`
  * `Ability:event_dispatch_with_args`
  * `Buff:event_on`
  * `Buff:event_notify`
  * `Buff:event_notify_with_args`
  * `Buff:event_dispatch`
  * `Buff:event_dispatch_with_args`
  * `Item:event_on`
  * `Item:event_notify`
  * `Item:event_notify_with_args`
  * `Item:event_dispatch`
  * `Item:event_dispatch_with_args`
  * `Unit:event_on`
  * `Unit:event_notify`
  * `Unit:event_notify_with_args`
  * `Unit:event_dispatch`
  * `Unit:event_dispatch_with_args`
  * `Player:event_on`
  * `Player:event_notify`
  * `Player:event_notify_with_args`
  * `Player:event_dispatch`
  * `Player:event_dispatch_with_args`

`2023-8-8`
+ 地图配置添加：
  * `y3.const.sync.key = true` - 启用按键同步，启用后才能获取玩家的键盘与鼠标按键状态
+ 添加了以下接口：
  * `Ability:storage_set(k, v)`
  * `Ability:storage_get(k, v)`
  * `Mover:storage_set(k, v)`
  * `Mover:storage_get(k, v)`
  * `Unit:bindGC(obj)`
  * `Item:bindGC(obj)`
  * `Buff:bindGC(obj)`
  * `Ability:bindGC(obj)`
  * `Mover:bindGC(obj)`
+ 修改以下接口的名称：
  * `Player:get_ui_pos_x` -> `Player:get_mouse_pos_x`
  * `Player:get_ui_pos_y` -> `Player:get_mouse_pos_y`
  * `y3.game.player_keyboard_key_is_pressed` -> `Player:is_key_pressed`
  * `y3.game.check_tech_key_precondition` -> `y3.technology.check_precondition_by_key`
  * `y3.game.get_text_config` -> `y3.game.locale`
  * `Point:set_collision` -> `y3.ground.set_collision`
  * `Point:get_ground_collision` -> `y3.ground.get_collision`
  * `Point:get_view_block_type` -> `y3.ground.get_view_block_type`
  * `y3.game.get_point_ground_height` -> `y3.ground.get_height_level`
  * `y3.game.get_random_seed` -> `y3.math.get_random_seed`
+ 移除了以下接口：
  * `y3.game.player_mouse_key_is_pressed`，该功能已合并到 `Player:is_key_pressed` 中
  * `y3.game.print_to_dialog`，请改用 `log.info`/`log.debug`/`log.warn`/`log.error`
  * `y3.game.test_show_message_tip`
  * `y3.game.test_log_message`
  * `y3.game.test_add_log_assert_result`
  * `y3.game.joint_string`，改用Lua的字符串拼接语法
  * `y3.game.extract_string`，改用 `string.sub`
  * `y3.game.delete_sub_string`，改用 `string.gsub`
  * `y3.game.get_random_pool_probability`
  * `y3.game.get_int_value_from_random_pool`
  * `y3.game.get_random_pool_all_weight`
  * `y3.game.get_random_pool_size`
  * `y3.game.get_random_pool_pointed_weight`

`2023-8-7`
+ 添加了地图配置功能，目前可用的配置为：
  * `y3.config.sync.mouse = true` - 启用鼠标同步，启用后才能获取玩家的鼠标位置
  * `y3.config.sync.camera = true` - 启用镜头同步，启用后才能获取玩家的镜头方向与中心点位置

`2023-8-4`
+ 添加了以下接口：
  * `y3.ui.set_cursor(player, state, key)`
+ 修复：
  * `Buff:set_shield`, `Buff:add_shield` 报错（#54）

`2023-8-3`
+ 添加了以下接口：
  * `Player:storage_set(k, v)`
  * `Player:storage_get(k)`
  * `Item:storage_set(k, v)`
  * `Item:storage_get(k)`
  * `Buff:storage_set(k, v)`
  * `Buff:storage_get(k)`
+ 修复：
  * `Area:get_all_unit_in_area` 报错（#69）

`2023-8-2`
+ 添加了以下接口：
  * `Timer:execute(...)`
  * `Unit:storage_set(k, v)`
  * `Unit:storage_get(k)`
+ 现在会维护 `Unit` 的引用，同一个单位的 `Unit` 对象总是相同的
+ 修复：
  * 在事件回调参数中获取 `from_unit` 字段会报错（#59）

`2023-8-1`
* `Unit:add_buff` 现在会返回 `Buff?`
* 添加了以下接口：
  * `UI:set_follow_mouse`
* 添加了 `Sound` 类
* 移除了 `y3.game` 中声音相关的接口，请改用 `Sound` 类中的方法
  * `y3.game.play_sound_for_player` -> `y3.sound.play`
  * `y3.game.stop_sound_for_player` -> `Sound:stop`
  * `y3.game.play_3d_sound_for_player` -> `y3.sound.play_3d`
  * `y3.follow_object_play_3d_sound_for_player` -> `y3.sound.play_with_object`
  * `y3.set_sound_volume` -> `Sound:set_volume`

`2023-7-31`
* 修复运动器的碰撞单位事件无法获取碰撞单位的问题。
* 在伤害事件的回调参数中添加了 `damage_instance`，你可以通过这个对象的方法修改伤害、修改是否闪避等。
* 事件回调参数中类型为 `py.Fixed` 的字段现在是 `number` 类型了。
* `UI:get_child` 获取不存在的控件时会返回 `nil` 了（之前是报错），现在需要你自己判空。

`2023-7-28`
* 增加了新的类 `Cast`，可以在该对象上获取某次施法的目标、方向等信息。
* 移除了 `Ability` 类中获取施法目标相关的接口，它们之前就无法正常工作。
* 施法事件的回调参数中新增字段 `cast: Cast`
* 移除了以下接口
  * `Ability` 类中获取施法目标相关的接口，改用 `Cast` 类中的相关接口。`Cast` 对象会在施法相关的事件中作为回调参数。
  * `y3.math.get_points_angle`，改用 `Point:get_angle_with()`
  * `y3.math.get_two_points_distance`，改用 `Point:get_distance_with()`

`2023-7-27`
* 重命名了以下接口：
  * `y3.game.get_max_tech_level` -> `y3.game.get_tech_max_level`
  * `y3.game.get_tech_type_description` -> `y3.game.get_tech_description`
  * `y3.game.get_tech_type_name` -> `y3.game.get_tech_name`
  * `y3.game.start_new_round_of_game` -> `y3.game.restart_game`
  * `y3.game.set_damage_factor` -> `y3.game.set_damage_ratio`
  * `y3.game.set_game_time_elapsing_rate` -> `y3.game.set_day_night_speed`
  * `y3.game.set_game_time` -> `y3.game.set_day_night_time`
  * `y3.game.create_artificial_time` -> `y3.game.create_day_night_human_time`
  * `y3.game.toggle_time_elapsing_is_on` -> `y3.game.toggle_day_night_time`
  * `y3.game.toggle_target_point_grassland_is_on` -> `y3.game.enable_grass_by_pos`
  * `y3.game.get_current_game_time` -> `y3.game.get_day_night_time`
  * `y3.game.get_damage_factor` -> `y3.game.get_damage_ratio`
  * `y3.game.get_coefficient` -> `y3.game.get_compound_attributes`
  * `y3.game.get_game_environment_of_current_round` -> `y3.game.get_start_mode`
  * `y3.game.if_pri_attr_state_open` -> `y3.game.is_compound_attributes_enabled`
* 移除了以下接口：
  * 所有和table相关的API，请改用Lua自己的API。
  * 所有用于事件响应获取参数的API，请在事件的回调参数中获得。
  * `y3.game.get_local_language_environment`
  * `y3.game.get_mover_bound_projectiles`
  * `y3.game.get_ability_owner`，改用 `Ability:get_owner()`
  * `y3.game.modifier_provider`，改用 `Buff:get_source()`
  * `y3.game.get_number_interval`，改用 `y3.math.isBetween`
  * `y3.game.all_units_belonging_to_specified_player`，改用 `Player:get_all_units()`
  * `y3.game.unit_of_a_specified_unit_type`，改用 `y3.unit_group.pick_by_key`
  * `y3.game.integer_random_units_from_unit_group`，改用 `UnitGroup:pick_random_n()`
  * `y3.game.number_of_units_in_unit_group`，改用 `UnitGroup:count()`
  * `y3.game.get_number_of_units_of_specified_type_in_unit_group`，改用 `UnitGroup:count_by_key()`
  * `y3.game.get_the_first_unit_in_a_unit_group`，改用 `UnitGroup:get_first()`
  * `y3.game.get_random_unit_from_unit_group`，改用 `UnitGroup:get_random()`
  * `y3.game.clear`
  * `y3.game.play_screen_particle_for_a_set_duration`，改用 `y3.particle.create_screen`
  * `y3.game.is_point_in_area`，改用 `Area:is_point_in_area()`
